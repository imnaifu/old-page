Big-O | Name | Description
------| ---- | -----------
**O(1)** | 常数级 | **最好的**。不论输入数据量有多大，这个算法的运行时间总是一样的。例子: 基于索引取出数组中对应的元素。
**O(log n)** | 对数级 | **相当好**。这种算法每次循环时会把需要处理的数据量减半。如果你有 100 个元素，则只需要七步就可以找到答案。1000 个元素只要十步。100,0000 元素只要二十步。即便数据量很大这种算法也非常快。例子：二分查找。
**O(n)** | 线性级 | **还不错**。如果你有 100 个元素，这种算法就要做 100 次工作。数据量翻倍那么运行时间也翻倍。例子：线性查找。
**O(n log n)** | 线性对数级 | **还可以**。比线性级差了一些，不过也没那么差劲。例子：最快的通用排序算法。
**O(n^2)** | 二次方级 | **有点慢**。如果你有 100 个元素，这种算法需要做 100^2 = 10000 次工作。数据量 x 2 会导致运行时间 x 4 (因为 2 的 2 次方等于 4)。例子：循环套循环的算法，比如插入排序。
**O(n^3)** | 三次方级 | **特别慢**。如果你有 100 个元素，那么这种算法就要做 100^3 = 100,0000 次工作。数据量 x 2 会导致运行时间 x 8。例子：矩阵乘法。
**O(2^n)** | 指数级 | **超级慢**。这种算法你要想方设法避免，但有时候你就是没得选。加一点点数据就会把运行时间成倍的加长。例子：旅行商问题。
**O(n!)** | 阶乘级 | **比蜗牛还慢**！不管干什么都要跑个 N 年才能得到结果。



![i](https://apelbaum.files.wordpress.com/2011/10/yaacovapelbaumbigoplot.jpg)
