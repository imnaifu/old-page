# P问题（polynomial problem）
- can be done within polynomial time 
- like o(n^2), o(n^3)
- 算起来很快的问题

# NP问题
- 算起来不一定很快，但是可以在多项式时间内验证一个答案对不对

# NPC问题
- 算起来不一定快，同时也没办法在多项式时间内验证

# Big O noation

Big-O | Name | Description
------| ---- | -----------
**O(1)** | 常数级 | **最好的**。不论输入数据量有多大，这个算法的运行时间总是一样的。例子: 基于索引取出数组中对应的元素。
**O(log n)** | 对数级 | **相当好**。这种算法每次循环时会把需要处理的数据量减半。如果你有 100 个元素，则只需要七步就可以找到答案。1000 个元素只要十步。100,0000 元素只要二十步。即便数据量很大这种算法也非常快。例子：二分查找。
**O(n)** | 线性级 | **还不错**。如果你有 100 个元素，这种算法就要做 100 次工作。数据量翻倍那么运行时间也翻倍。例子：线性查找。
**O(n log n)** | 线性对数级 | **还可以**。比线性级差了一些，不过也没那么差劲。例子：最快的通用排序算法。
**O(n^2)** | 二次方级 | **有点慢**。如果你有 100 个元素，这种算法需要做 100^2 = 10000 次工作。数据量 x 2 会导致运行时间 x 4 (因为 2 的 2 次方等于 4)。例子：循环套循环的算法，比如插入排序。
**O(n^3)** | 三次方级 | **特别慢**。如果你有 100 个元素，那么这种算法就要做 100^3 = 100,0000 次工作。数据量 x 2 会导致运行时间 x 8。例子：矩阵乘法。
**O(2^n)** | 指数级 | **超级慢**。这种算法你要想方设法避免，但有时候你就是没得选。加一点点数据就会把运行时间成倍的加长。例子：旅行商问题。
**O(n!)** | 阶乘级 | **比蜗牛还慢**！不管干什么都要跑个 N 年才能得到结果。

# 动态规划（Dynamic Programming）
- 计算机可以被视为有限状态机（Finite State Machine）
- 每个状态被保存在内存，并且可以改变成下一个状态
- 当前状态可以有之前的状态决定
- 一个状态可以有很多种可能性（比如围棋）

1. 只有一种可能 -> 递归
2. 每个状态的最优选择都是由上一个状态的最优选择得到的 -> 贪心
3. 每个状态的最优选择都是由之前所有阶段的选择得到的 -> 搜索
4. 每个状态的最优选择可以从之前某个状态的某个或某些选择直接得到而不管之前这个选择是如何得到的 -> 动态规划


# Ref
- [https://apelbaum.files.wordpress.com/2011/10/yaacovapelbaumbigoplot.jpg](https://apelbaum.files.wordpress.com/2011/10/yaacovapelbaumbigoplot.jpg)
